<?php

namespace Nuwave\Lighthouse\Console;

use HaydenPierce\ClassFinder\ClassFinder;
use Illuminate\Console\Command;
use Nuwave\Lighthouse\Schema\AST\PartialParser;
use Nuwave\Lighthouse\Schema\DirectiveNamespacer;
use Nuwave\Lighthouse\Schema\Factories\DirectiveFactory;
use Nuwave\Lighthouse\Support\Contracts\DefinedDirective;
use Nuwave\Lighthouse\Support\Contracts\Directive;

class IdeHelperCommand extends Command
{
    public const GENERATED_NOTICE = <<<'SDL'
# File generated by "php artisan lighthouse:ide-helper".
# Do not edit this file directly.
# This file should be ignored by git as it can be autogenerated.

SDL;

    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'lighthouse:ide-helper';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Create IDE helper files to improve type checking and autocompletion.';

    /**
     * Execute the console command.
     */
    public function handle(DirectiveNamespacer $directiveNamespaces): int
    {
        if (! class_exists('HaydenPierce\ClassFinder\ClassFinder')) {
            $this->error(
                "This command requires haydenpierce/class-finder. Install it by running:\n"
                ."\n"
                ."    composer require --dev haydenpierce/class-finder\n"
            );

            return 1;
        }

        $this->schemaDirectiveDefinitions($directiveNamespaces);
        $this->phpIdeHelper();

        $this->info("\nIt is recommended to add them to your .gitignore file.");

        return 0;
    }

    /**
     * Scan the given namespaces for directive classes.
     *
     * @param  string[]  $directiveNamespaces
     * @return string[]
     */
    protected function scanForDirectives(array $directiveNamespaces): array
    {
        $directives = [];

        foreach ($directiveNamespaces as $directiveNamespace) {
            $classesInNamespace = ClassFinder::getClassesInNamespace($directiveNamespace);

            foreach ($classesInNamespace as $class) {
                $reflection = new \ReflectionClass($class);
                if (! $reflection->isInstantiable()) {
                    continue;
                }

                if (! is_a($class, Directive::class, true)) {
                    continue;
                }

                $name = DirectiveFactory::directiveName($class);

                // The directive was already found, so we do not add it twice
                if (isset($directives[$name])) {
                    continue;
                }

                $directives[$name] = $class;
            }
        }

        return $directives;
    }

    /**
     * @param string[] $directiveClasses
     */
    protected function buildSchemaString(array $directiveClasses): string
    {
        $schema = self::GENERATED_NOTICE;

        foreach ($directiveClasses as $name => $directiveClass) {
            $definition = $this->define($name, $directiveClass);

            $schema .= "\n"
                ."# Directive class: $directiveClass\n"
                .$definition."\n";
        }

        return $schema;
    }

    protected function define(string $name, string $directiveClass): string
    {
        if (is_a($directiveClass, DefinedDirective::class, true)) {
            /** @var DefinedDirective $directiveClass */
            $definition = $directiveClass::definition();

            // This operation throws if the schema definition is invalid
            PartialParser::directiveDefinition($definition);

            return trim($definition);
        }

        return '# Add a proper definition by implementing '.DefinedDirective::class."\n"
            ."directive @{$name}";
    }

    /**
     * Create and write schema directive definitions to a file.
     */
    protected function schemaDirectiveDefinitions(DirectiveNamespacer $directiveNamespaces): void
    {
        $directiveClasses = $this->scanForDirectives(
            $directiveNamespaces->gather()
        );

        $schema = $this->buildSchemaString($directiveClasses);

        $filePath = static::schemaDirectivesPath();
        file_put_contents($filePath, $schema);

        $this->info("Wrote schema directive definitions to $filePath.");
    }

    public static function schemaDirectivesPath(): string
    {
        return base_path().'/schema-directives.graphql';
    }

    protected function phpIdeHelper(): void
    {
        $filePath = static::phpIdeHelperPath();
        copy(__DIR__.'/../../_ide_helper.php', $filePath);

        $this->info("Wrote PHP definitions to $filePath.");
    }

    public static function phpIdeHelperPath(): string
    {
        return base_path().'/_lighthouse_ide_helper.php';
    }
}
